<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Modbus cpp: Modbus cpp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Modbus cpp<span id="projectnumber">&#160;0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Modbus cpp </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> </p><h1>Modbus library for modern c++</h1>
<p>Modbus library for high level frame manipulation with modern C++17.</p>
<p>Contains simple linux TCP and RTU implementation.</p>
<h1><a class="anchor" id="autotoc_md0"></a>
Contents</h1>
<ul>
<li>Why</li>
<li>Important Concept</li>
<li>Possibilities</li>
<li>Dependencies</li>
<li>Status</li>
<li>Installation</li>
<li>Api</li>
</ul>
<h1><a class="anchor" id="autotoc_md1"></a>
Why</h1>
<p>When I was working on my last project and tried to find a good c++ Modbus library (other than Qt) I was unable to find it. That is why I have decided to share my own implementation of it.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Important Concept</h1>
<p>This library is <b>mainly</b> for providing Modbus logic, it doesnt aim to have best communiaction implementation. It gives user ability to create Modbus frames in high level api and convert them to raw bytes or show them as string. That is why <em>Modbus Core</em> is OS independent and can be easily used with other communication frameworks.</p>
<p>It does have communiaction module which is <b>enabled</b> by default, and works pretty well on linux.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Possibilities</h1>
<p>Quick example of what Modbus Core can do:</p>
<p>Code: </p><div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;modbusRequest.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create simple request</span></div>
<div class="line"><a class="code hl_class" href="classMB_1_1ModbusRequest.html">MB::ModbusRequest</a> request(1, MB::utils::ReadDiscreteOutputCoils, 100, 10);</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Stringed Request: &quot;</span> &lt;&lt; request.toString() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Raw request:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Get raw represenatation for request</span></div>
<div class="line">std::vector&lt;uint8_t&gt; rawed = request.toRaw();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Method for showing byte</span></div>
<div class="line"><span class="keyword">auto</span> showByte = [](<span class="keyword">const</span> uint8_t&amp; byte)</div>
<div class="line">{</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot; 0x&quot;</span> &lt;&lt; std::hex &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#39;0&#39;) &lt;&lt; static_cast&lt;int&gt;(<span class="keywordtype">byte</span>);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Show all bytes</span></div>
<div class="line">std::for_each(rawed.begin(), rawed.end(), showByte);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create CRC and pointer to its bytes</span></div>
<div class="line">uint16_t CRC = <a class="code hl_function" href="namespaceMB_1_1utils.html#aa419ed339bbdacd4108fb5cc1cd14539">MB::utils::calculateCRC</a>(rawed);</div>
<div class="line"><span class="keyword">auto</span> CRCptr = <span class="keyword">reinterpret_cast&lt;</span>uint8_t *<span class="keyword">&gt;</span>(&amp;CRC);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Show byted CRC for request</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;CRC for the above code: &quot;</span>;</div>
<div class="line">std::for_each(CRCptr, CRCptr + 2, showByte);</div>
<div class="line">std::cout &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> request1 = MB::ModbusRequest::fromRaw(rawed);</div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Stringed Request 1 after rawed: &quot;</span> &lt;&lt; request1.toString() &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add CRC to the end of raw request so that it can be loaded with CRC check</span></div>
<div class="line">rawed.insert(rawed.end() , CRCptr, CRCptr + 2);</div>
<div class="line"><span class="keyword">auto</span> request2 = MB::ModbusRequest::fromRawCRC(rawed); <span class="comment">// Throws on invalid CRC</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Stringed Request 2 after rawed: &quot;</span> &lt;&lt; request2.toString() &lt;&lt; std::endl;</div>
<div class="ttc" id="aclassMB_1_1ModbusRequest_html"><div class="ttname"><a href="classMB_1_1ModbusRequest.html">MB::ModbusRequest</a></div><div class="ttdef"><b>Definition</b> modbusRequest.hpp:23</div></div>
<div class="ttc" id="anamespaceMB_1_1utils_html_aa419ed339bbdacd4108fb5cc1cd14539"><div class="ttname"><a href="namespaceMB_1_1utils.html#aa419ed339bbdacd4108fb5cc1cd14539">MB::utils::calculateCRC</a></div><div class="ttdeci">uint16_t calculateCRC(const uint8_t *buff, size_t len)</div><div class="ttdoc">Calculates CRC.</div><div class="ttdef"><b>Definition</b> modbusUtils.hpp:215</div></div>
</div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">Stringed Request: Read from output coils, from slave 1, starting from address 100, on 10 registers</div>
<div class="line">Raw request:</div>
<div class="line"> 0x01 0x01 0x00 0x64 0x00 0x0a</div>
<div class="line">CRC for the above code:  0xfd 0xd2</div>
<div class="line">Stringed Request 1 after rawed: Read from output coils, from slave 1, starting from address 100, on 10 registers</div>
<div class="line">Stringed Request 2 after rawed: Read from output coils, from slave 1, starting from address 100, on 10 registers</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md4"></a>
Dependencies</h1>
<ul>
<li>libnet - only for tcp communication (not needed if communication is disabled)</li>
</ul>
<h1><a class="anchor" id="autotoc_md5"></a>
STATUS</h1>
<p>Currently Modbus Core is fully functional and (I belive) it doesn't have any bugs.</p>
<p>API for it is in progress.</p>
<p>Modbus Communication is working <em>currently</em> only for linux, it works well on TCP and Serial (tested on raspberry pi).</p>
<h1><a class="anchor" id="autotoc_md6"></a>
How to learn Modbus ?</h1>
<p>Just use <a href="http://www.simplymodbus.ca/FAQ.htm">Simply modbus</a>.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
How to install it ?</h1>
<h3><a class="anchor" id="autotoc_md8"></a>
Using CMAKE and git</h3>
<p>First go to directory that will contain this library.</p>
<div class="fragment"><div class="line">git clone https://github.com/Mazurel/Modbus</div>
<div class="line">git submodule update --init --recursive # Fetch submodules (google tests)</div>
</div><!-- fragment --><p>Then add to your CMakeLists.txt </p><div class="fragment"><div class="line">add_subdirectory(Modbus)</div>
<div class="line">target_link_libraries(&lt;your exec/lib&gt; Modbus)</div>
</div><!-- fragment --><p> You should be able to use library.</p>
<p><b>NOTE</b> If you are on other os then gnu/linux you should disable communication part of modbus via cmake variable MODBUS_COMMUNICATION.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
API</h1>
<p><a href="https://raw.githack.com/Mazurel/Modbus/master/docs/html/index.html">link</a></p>
<h2><a class="anchor" id="autotoc_md10"></a>
It is the best to use docs generated by doxygen</h2>
<p>You can read it in <a href="https://raw.githack.com/Mazurel/Modbus/master/docs/html/index.html">docs/html</a> or generate it yourself via: </p><div class="fragment"><div class="line">doxygen Doxyfile</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
The below API is not finished (propably wont be), it is preffered to use doxygen for code documentation.</h2>
<ul>
<li>Enums</li>
<li>Methods</li>
<li>Classes</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
Enums</h2>
<p>Below each enum there are all values of enum.</p><ul>
<li><code><a class="el" href="namespaceMB_1_1utils.html#aa34c557c9bf4c6bfeb86aa16b398de55">MB::utils::MBErrorCode</a></code> - Enum that contains all the standard Modbus error Codes as well as Modbus library specific errors. <div class="fragment"><div class="line">++</div>
<div class="line">   <span class="comment">// Documentation modbus errors:</span></div>
<div class="line">   IllegalFunction = 0x01</div>
<div class="line">   IllegalDataAddress = 0x02</div>
<div class="line">   IllegalDataValue = 0x03</div>
<div class="line">   SlaveDeviceFailure = 0x04</div>
<div class="line">   Acknowledge = 0x05</div>
<div class="line">   SlaveDeviceBusy = 0x06</div>
<div class="line">   NegativeAcknowledge = 0x07</div>
<div class="line">   MemoryParityError = 0x08</div>
<div class="line">   GatewayPathUnavailable = 0x10</div>
<div class="line">   GatewayTargetDeviceFailedToRespond = 0x11</div>
<div class="line"> </div>
<div class="line">   <span class="comment">// Custom modbus errors:</span></div>
<div class="line">   ErrorCodeCRCError = 0b0111111</div>
<div class="line">   InvalidCRC = 0b01111110</div>
<div class="line">   InvalidByteOrder = 0b01111101</div>
<div class="line">   InvalidMessageID = 0b01111100</div>
<div class="line">   ProtocolError = 0b01111011</div>
<div class="line">   ConnectionClosed = 0b01111010</div>
<div class="line">   Timeout = 0b01111001</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#aa8ebb89b73bf4d0e3485b6341a50f116" title="All modbus standard function codes + Undefined one.">MB::utils::MBFunctionCode</a></code> - Enum that contains all Modbus function codes. <div class="fragment"><div class="line">++</div>
<div class="line">   <span class="comment">// Reading functions</span></div>
<div class="line">   ReadDiscreteOutputCoils = 0x01</div>
<div class="line">   ReadDiscreteInputContacts = 0x02</div>
<div class="line">   ReadAnalogOutputHoldingRegisters = 0x03</div>
<div class="line">   ReadAnalogInputRegisters = 0x04</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Single write functions</span></div>
<div class="line">   WriteSingleDiscreteOutputCoil = 0x05</div>
<div class="line">   WriteSingleAnalogOutputRegister = 0x06</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Multiple write functions</span></div>
<div class="line">   WriteMultipleDiscreteOutputCoils = 0x0F</div>
<div class="line">   WriteMultipleAnalogOutputHoldingRegisters = 0x10</div>
<div class="line">   </div>
<div class="line">   <span class="comment">// Custom</span></div>
<div class="line">   Undefined = 0x00</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a0b3590994f5ba26cd61929f5a394ab70" title="Simplified function types.">MB::utils::MBFunctionType</a></code> - Enum that contains function types. <div class="fragment"><div class="line">++</div>
<div class="line">   Read</div>
<div class="line">   WriteSingle</div>
<div class="line">   WriteMultiple</div>
</div><!-- fragment --></li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a8098c5bcb6c33b219bafdee42334e260" title="Simplified register types.">MB::utils::MBFunctionRegisters</a></code> - Enum that contains all register types. <div class="fragment"><div class="line">++        </div>
<div class="line">   OutputCoils</div>
<div class="line">   InputContacts</div>
<div class="line">   HoldingRegisters</div>
<div class="line">   InputRegisters</div>
</div><!-- fragment --> <br  />
</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Methods</h2>
<ul>
<li><code>bool MB::utils::isStandardErrorCode(MBErrorCode code)</code> - Returns true if specified code is a Modbus standard error code.</li>
<li><code>std::string MB::utils::mbErrorCodeToStr(MBErrorCode code)</code> - Returns stringed name of a specified Modbus error code. <br  />
</li>
<li><code>MBFunctionType MB::utils::functionType(const MBFunctionCode code)</code> - Get functions type based on function code.</li>
<li><code>MBFunctionRegisters MB::utils::functionRegister(const MBFunctionCode code)</code> - Get functions register based on function code.</li>
<li><code>uint16_t <a class="el" href="namespaceMB_1_1utils.html#a2057e90dfbefb2bc7cea23f6140d5a04" title="Create uint16_t from buffer of two bytes, ex. { 0x01, 0x02 } =&gt; 0x0102.">MB::utils::bigEndianConv(const uint8_t *buf)</a></code> - Creates uint16_t number from uint8_t buffer of two bytes (used when reading modbus frames).</li>
<li><p class="startli"><code>uint16_t <a class="el" href="namespaceMB_1_1utils.html#aa419ed339bbdacd4108fb5cc1cd14539" title="Calculates CRC.">MB::utils::calculateCRC(const uint8_t *buff, size_t len)</a></code></p>
<p class="startli"><code>uint16_t <a class="el" href="namespaceMB_1_1utils.html#aa419ed339bbdacd4108fb5cc1cd14539" title="Calculates CRC.">MB::utils::calculateCRC</a>(const std::vector&lt;uint8_t&gt;&amp; buffer)</code> - Pretty self explanatory. </p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Classes</h2>
<blockquote class="doxtable">
<p>&zwj;For each getter and setter field there is:</p>
<p>&lt;name&gt;() const - that gets the value</p>
<p>set&lt;Name&gt;(value) - that sets value </p>
</blockquote>
<h4><a class="anchor" id="autotoc_md15"></a>
ModbusException</h4>
<p>Its prupose is to represent Modbus exception, either frame or c++ exception</p>
<ul>
<li>Constructor:<ul>
<li><code>ModbusException(const std::vector&lt;uint8_t&gt;&amp; inputData, bool CRC = false);</code> - Creates ModbusException from raw bytes, with CRC check based on parameter.</li>
<li><code>ModbusException(utils::MBErrorCode errorCode, uint8_t slaveId = 0xFF, utils::MBFunctionCode functionCode = utils::Undefined) noexcept : _slaveId(slaveId), _validSlave(true), _errorCode(errorCode), _functionCode(functionCode) {}</code> - Creates Modbus exception based on it's properties.</li>
</ul>
</li>
<li>Methods:<ul>
<li><code>static ModbusException::exist(const std::vector&lt;uint8_t&gt;&amp; inputData)</code> - Checks if there is exception in modbus frame.</li>
<li><code>std::string toString()</code> - Returns string representation of exception.</li>
<li><code>std::vector&lt;uint8_t&gt; toRaw()</code> - Retruns raw frame represenation of a excaption.</li>
</ul>
</li>
<li>Getters and setters:<ul>
<li>functionCode</li>
<li>slaveID</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md16"></a>
ModbusRequest</h4>
<p>Its purpose is to represent modbus request frame.</p>
<ul>
<li>Constructors:<ul>
<li><code>static ModbusRequest(std::vector&lt;uint8_t&gt; inputData, bool CRC = false)</code> - Creates Modbus request based on raw bytes and CRC boolean. If CRC is ON and the check fails constructor throws exception.</li>
<li><code>static ModbusRequest::fromRaw(const std::vector&lt;uint8_t&gt;&amp; inputData)</code> - Creates ModbusRequest from raw bytes.</li>
<li><code>static ModbusRequest::fromRawCRC(const std::vector&lt;uint8_t&gt;&amp; inputData)</code> - Creates ModbusRequest from raw bytes and checks CRC. When CRC is invalid throws InvalidCRC exception.</li>
<li><code>ModbusRequest(uint8_t slaveId = 0, utils::MBFunctionCode functionCode = static_cast&lt;utils::MBFunctionCode&gt;(0), uint16_t address = 0, uint16_t registersNumber = 0, std::vector&lt;ModbusCell&gt; values = {})</code> - Self explanatory.</li>
</ul>
</li>
<li>Methods:<ul>
<li><code>std::string ModbusRequest::toString()</code> - Returns string representation of a request.</li>
<li><code>std::vector&lt;uint8_t&gt; ModbusRequest::toRaw()</code> - Converts ModbusRequest to raw bytes.</li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a0b3590994f5ba26cd61929f5a394ab70" title="Simplified function types.">MB::utils::MBFunctionType</a> functionType() const</code> - Gets function type for current function code.</li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a8098c5bcb6c33b219bafdee42334e260" title="Simplified register types.">MB::utils::MBFunctionRegisters</a> functionRegisters() const</code> - Gets function register for current function code.</li>
</ul>
</li>
<li>Getters and setters:<ul>
<li>slaveID</li>
<li>functionCode</li>
<li>registerAddress</li>
<li>numberOfRegisters</li>
<li>registerValues</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="autotoc_md17"></a>
ModbusResponse</h4>
<p>Its purpose is to represent response frame.</p>
<ul>
<li>Constructors:<ul>
<li><code>static ModbusResponse(std::vector&lt;uint8_t&gt; inputData, bool CRC = false)</code> - Creates Modbus response based on raw bytes and CRC boolean. If CRC is ON and the check fails constructor throws exception.</li>
<li><code>static ModbusResponse::fromRaw(const std::vector&lt;uint8_t&gt;&amp;)</code> - Creates ModbusResponse from raw bytes</li>
<li><code>static ModbusResponse::fromRawCRC(const std::vector&lt;uint8_t&gt;&amp;)</code> - Creates ModbusResponse from raw bytes and checks CRC. When CRC is invalid throws InvalidCRC exception.</li>
<li><code>ModbusResponse(uint8_t slaveId = 0, utils::MBFunctionCode functionCode = 0x00, uint16_t address = 0, uint16_t registersNumber = 0, std::vector&lt;ModbusCell&gt; values = {})</code><ul>
<li>Self explanatory constructor.</li>
</ul>
</li>
</ul>
</li>
<li>Methods:<ul>
<li><code>std::string toString()</code> - Returns ModbusResponse string representation.</li>
<li><code>std::vector&lt;uint8_t&gt; toRaw()</code> - Converts ModbusResponse to vector of raw bytes.</li>
<li><code>void from(const ModbusRequest&amp;)</code> - Fills ModbusResponse with the request. Needed if you want ModbusResponse to have all the data. This method is needed when you create object from raw.</li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a0b3590994f5ba26cd61929f5a394ab70" title="Simplified function types.">MB::utils::MBFunctionType</a> functionType() const</code> - Gets function type for current function code.</li>
<li><code><a class="el" href="namespaceMB_1_1utils.html#a8098c5bcb6c33b219bafdee42334e260" title="Simplified register types.">MB::utils::MBFunctionRegisters</a> functionRegisters() const</code> - Gets function register for current function code.</li>
</ul>
</li>
<li>Getters and setters:<ul>
<li>slaveID</li>
<li>functionCode</li>
<li>registerAddress</li>
<li>numberOfRegisters</li>
<li>registerValues </li>
</ul>
</li>
</ul>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
